第1步
当前分析栈:# <program> 
剩余输入串:int ID = INT_VALUE ; ID = ID + INT_VALUE ; write ( ID ) ; # 
推导所用产生式:<program> -> <block>

第2步
当前分析栈:# <block> 
剩余输入串:int ID = INT_VALUE ; ID = ID + INT_VALUE ; write ( ID ) ; # 
推导所用产生式:<block> -> <declare_closure> <block_closure>

第3步
当前分析栈:# <block_closure> <declare_closure> 
剩余输入串:int ID = INT_VALUE ; ID = ID + INT_VALUE ; write ( ID ) ; # 
推导所用产生式:<declare_closure> -> <per_declaration> <declare_closure>

第4步
当前分析栈:# <block_closure> <declare_closure> <per_declaration> 
剩余输入串:int ID = INT_VALUE ; ID = ID + INT_VALUE ; write ( ID ) ; # 
推导所用产生式:<per_declaration> -> <declare> <per_declare_closure> ;

第5步
当前分析栈:# <block_closure> <declare_closure> ; <per_declare_closure> <declare> 
剩余输入串:int ID = INT_VALUE ; ID = ID + INT_VALUE ; write ( ID ) ; # 
推导所用产生式:<declare> -> <type> <variable> <initialization>

第6步
当前分析栈:# <block_closure> <declare_closure> ; <per_declare_closure> <initialization> <variable> <type> 
剩余输入串:int ID = INT_VALUE ; ID = ID + INT_VALUE ; write ( ID ) ; # 
推导所用产生式:<type> -> int

第7步
当前分析栈:# <block_closure> <declare_closure> ; <per_declare_closure> <initialization> <variable> int 
剩余输入串:int ID = INT_VALUE ; ID = ID + INT_VALUE ; write ( ID ) ; # 
匹配 :int

第8步
当前分析栈:# <block_closure> <declare_closure> ; <per_declare_closure> <initialization> <variable> 
剩余输入串:ID = INT_VALUE ; ID = ID + INT_VALUE ; write ( ID ) ; # 
推导所用产生式:<variable> -> <identifier> <index>

第9步
当前分析栈:# <block_closure> <declare_closure> ; <per_declare_closure> <initialization> <index> <identifier> 
剩余输入串:ID = INT_VALUE ; ID = ID + INT_VALUE ; write ( ID ) ; # 
推导所用产生式:<identifier> -> ID

第10步
当前分析栈:# <block_closure> <declare_closure> ; <per_declare_closure> <initialization> <index> ID 
剩余输入串:ID = INT_VALUE ; ID = ID + INT_VALUE ; write ( ID ) ; # 
匹配 :ID

第11步
当前分析栈:# <block_closure> <declare_closure> ; <per_declare_closure> <initialization> <index> 
剩余输入串:= INT_VALUE ; ID = ID + INT_VALUE ; write ( ID ) ; # 
推导所用产生式:<index> -> $

第12步
当前分析栈:# <block_closure> <declare_closure> ; <per_declare_closure> <initialization> 
剩余输入串:= INT_VALUE ; ID = ID + INT_VALUE ; write ( ID ) ; # 
推导所用产生式:<initialization> -> = <right_value>

第13步
当前分析栈:# <block_closure> <declare_closure> ; <per_declare_closure> <right_value> = 
剩余输入串:= INT_VALUE ; ID = ID + INT_VALUE ; write ( ID ) ; # 
匹配 :=

第14步
当前分析栈:# <block_closure> <declare_closure> ; <per_declare_closure> <right_value> 
剩余输入串:INT_VALUE ; ID = ID + INT_VALUE ; write ( ID ) ; # 
推导所用产生式:<right_value> -> <expression>

第15步
当前分析栈:# <block_closure> <declare_closure> ; <per_declare_closure> <expression> 
剩余输入串:INT_VALUE ; ID = ID + INT_VALUE ; write ( ID ) ; # 
推导所用产生式:<expression> -> <factor> <term>

第16步
当前分析栈:# <block_closure> <declare_closure> ; <per_declare_closure> <term> <factor> 
剩余输入串:INT_VALUE ; ID = ID + INT_VALUE ; write ( ID ) ; # 
推导所用产生式:<factor> -> <factor_type> <factor_recursion>

第17步
当前分析栈:# <block_closure> <declare_closure> ; <per_declare_closure> <term> <factor_recursion> <factor_type> 
剩余输入串:INT_VALUE ; ID = ID + INT_VALUE ; write ( ID ) ; # 
推导所用产生式:<factor_type> -> <number>

第18步
当前分析栈:# <block_closure> <declare_closure> ; <per_declare_closure> <term> <factor_recursion> <number> 
剩余输入串:INT_VALUE ; ID = ID + INT_VALUE ; write ( ID ) ; # 
推导所用产生式:<number> -> INT_VALUE

第19步
当前分析栈:# <block_closure> <declare_closure> ; <per_declare_closure> <term> <factor_recursion> INT_VALUE 
剩余输入串:INT_VALUE ; ID = ID + INT_VALUE ; write ( ID ) ; # 
匹配 :INT_VALUE

第20步
当前分析栈:# <block_closure> <declare_closure> ; <per_declare_closure> <term> <factor_recursion> 
剩余输入串:; ID = ID + INT_VALUE ; write ( ID ) ; # 
推导所用产生式:<factor_recursion> -> $

第21步
当前分析栈:# <block_closure> <declare_closure> ; <per_declare_closure> <term> 
剩余输入串:; ID = ID + INT_VALUE ; write ( ID ) ; # 
推导所用产生式:<term> -> $

第22步
当前分析栈:# <block_closure> <declare_closure> ; <per_declare_closure> 
剩余输入串:; ID = ID + INT_VALUE ; write ( ID ) ; # 
推导所用产生式:<per_declare_closure> -> $

第23步
当前分析栈:# <block_closure> <declare_closure> ; 
剩余输入串:; ID = ID + INT_VALUE ; write ( ID ) ; # 
匹配 :;

第24步
当前分析栈:# <block_closure> <declare_closure> 
剩余输入串:ID = ID + INT_VALUE ; write ( ID ) ; # 
推导所用产生式:<declare_closure> -> $

第25步
当前分析栈:# <block_closure> 
剩余输入串:ID = ID + INT_VALUE ; write ( ID ) ; # 
推导所用产生式:<block_closure> -> <assignment> <block>

第26步
当前分析栈:# <block> <assignment> 
剩余输入串:ID = ID + INT_VALUE ; write ( ID ) ; # 
推导所用产生式:<assignment> -> <variable> <assign> ;

第27步
当前分析栈:# <block> ; <assign> <variable> 
剩余输入串:ID = ID + INT_VALUE ; write ( ID ) ; # 
推导所用产生式:<variable> -> <identifier> <index>

第28步
当前分析栈:# <block> ; <assign> <index> <identifier> 
剩余输入串:ID = ID + INT_VALUE ; write ( ID ) ; # 
推导所用产生式:<identifier> -> ID

第29步
当前分析栈:# <block> ; <assign> <index> ID 
剩余输入串:ID = ID + INT_VALUE ; write ( ID ) ; # 
匹配 :ID

第30步
当前分析栈:# <block> ; <assign> <index> 
剩余输入串:= ID + INT_VALUE ; write ( ID ) ; # 
推导所用产生式:<index> -> $

第31步
当前分析栈:# <block> ; <assign> 
剩余输入串:= ID + INT_VALUE ; write ( ID ) ; # 
推导所用产生式:<assign> -> = <right_value>

第32步
当前分析栈:# <block> ; <right_value> = 
剩余输入串:= ID + INT_VALUE ; write ( ID ) ; # 
匹配 :=

第33步
当前分析栈:# <block> ; <right_value> 
剩余输入串:ID + INT_VALUE ; write ( ID ) ; # 
推导所用产生式:<right_value> -> <expression>

第34步
当前分析栈:# <block> ; <expression> 
剩余输入串:ID + INT_VALUE ; write ( ID ) ; # 
推导所用产生式:<expression> -> <factor> <term>

第35步
当前分析栈:# <block> ; <term> <factor> 
剩余输入串:ID + INT_VALUE ; write ( ID ) ; # 
推导所用产生式:<factor> -> <factor_type> <factor_recursion>

第36步
当前分析栈:# <block> ; <term> <factor_recursion> <factor_type> 
剩余输入串:ID + INT_VALUE ; write ( ID ) ; # 
推导所用产生式:<factor_type> -> <variable>

第37步
当前分析栈:# <block> ; <term> <factor_recursion> <variable> 
剩余输入串:ID + INT_VALUE ; write ( ID ) ; # 
推导所用产生式:<variable> -> <identifier> <index>

第38步
当前分析栈:# <block> ; <term> <factor_recursion> <index> <identifier> 
剩余输入串:ID + INT_VALUE ; write ( ID ) ; # 
推导所用产生式:<identifier> -> ID

第39步
当前分析栈:# <block> ; <term> <factor_recursion> <index> ID 
剩余输入串:ID + INT_VALUE ; write ( ID ) ; # 
匹配 :ID

第40步
当前分析栈:# <block> ; <term> <factor_recursion> <index> 
剩余输入串:+ INT_VALUE ; write ( ID ) ; # 
推导所用产生式:<index> -> $

第41步
当前分析栈:# <block> ; <term> <factor_recursion> 
剩余输入串:+ INT_VALUE ; write ( ID ) ; # 
推导所用产生式:<factor_recursion> -> $

第42步
当前分析栈:# <block> ; <term> 
剩余输入串:+ INT_VALUE ; write ( ID ) ; # 
推导所用产生式:<term> -> + <factor> <term>

第43步
当前分析栈:# <block> ; <term> <factor> + 
剩余输入串:+ INT_VALUE ; write ( ID ) ; # 
匹配 :+

第44步
当前分析栈:# <block> ; <term> <factor> 
剩余输入串:INT_VALUE ; write ( ID ) ; # 
推导所用产生式:<factor> -> <factor_type> <factor_recursion>

第45步
当前分析栈:# <block> ; <term> <factor_recursion> <factor_type> 
剩余输入串:INT_VALUE ; write ( ID ) ; # 
推导所用产生式:<factor_type> -> <number>

第46步
当前分析栈:# <block> ; <term> <factor_recursion> <number> 
剩余输入串:INT_VALUE ; write ( ID ) ; # 
推导所用产生式:<number> -> INT_VALUE

第47步
当前分析栈:# <block> ; <term> <factor_recursion> INT_VALUE 
剩余输入串:INT_VALUE ; write ( ID ) ; # 
匹配 :INT_VALUE

第48步
当前分析栈:# <block> ; <term> <factor_recursion> 
剩余输入串:; write ( ID ) ; # 
推导所用产生式:<factor_recursion> -> $

第49步
当前分析栈:# <block> ; <term> 
剩余输入串:; write ( ID ) ; # 
推导所用产生式:<term> -> $

第50步
当前分析栈:# <block> ; 
剩余输入串:; write ( ID ) ; # 
匹配 :;

第51步
当前分析栈:# <block> 
剩余输入串:write ( ID ) ; # 
推导所用产生式:<block> -> <declare_closure> <block_closure>

第52步
当前分析栈:# <block_closure> <declare_closure> 
剩余输入串:write ( ID ) ; # 
推导所用产生式:<declare_closure> -> $

第53步
当前分析栈:# <block_closure> 
剩余输入串:write ( ID ) ; # 
推导所用产生式:<block_closure> -> <functions> <block>

第54步
当前分析栈:# <block> <functions> 
剩余输入串:write ( ID ) ; # 
推导所用产生式:<functions> -> <function> ;

第55步
当前分析栈:# <block> ; <function> 
剩余输入串:write ( ID ) ; # 
推导所用产生式:<function> -> <write_fun>

第56步
当前分析栈:# <block> ; <write_fun> 
剩余输入串:write ( ID ) ; # 
推导所用产生式:<write_fun> -> write ( <data> )

第57步
当前分析栈:# <block> ; ) <data> ( write 
剩余输入串:write ( ID ) ; # 
匹配 :write

第58步
当前分析栈:# <block> ; ) <data> ( 
剩余输入串:( ID ) ; # 
匹配 :(

第59步
当前分析栈:# <block> ; ) <data> 
剩余输入串:ID ) ; # 
推导所用产生式:<data> -> <expression>

第60步
当前分析栈:# <block> ; ) <expression> 
剩余输入串:ID ) ; # 
推导所用产生式:<expression> -> <factor> <term>

第61步
当前分析栈:# <block> ; ) <term> <factor> 
剩余输入串:ID ) ; # 
推导所用产生式:<factor> -> <factor_type> <factor_recursion>

第62步
当前分析栈:# <block> ; ) <term> <factor_recursion> <factor_type> 
剩余输入串:ID ) ; # 
推导所用产生式:<factor_type> -> <variable>

第63步
当前分析栈:# <block> ; ) <term> <factor_recursion> <variable> 
剩余输入串:ID ) ; # 
推导所用产生式:<variable> -> <identifier> <index>

第64步
当前分析栈:# <block> ; ) <term> <factor_recursion> <index> <identifier> 
剩余输入串:ID ) ; # 
推导所用产生式:<identifier> -> ID

第65步
当前分析栈:# <block> ; ) <term> <factor_recursion> <index> ID 
剩余输入串:ID ) ; # 
匹配 :ID

第66步
当前分析栈:# <block> ; ) <term> <factor_recursion> <index> 
剩余输入串:) ; # 
推导所用产生式:<index> -> $

第67步
当前分析栈:# <block> ; ) <term> <factor_recursion> 
剩余输入串:) ; # 
推导所用产生式:<factor_recursion> -> $

第68步
当前分析栈:# <block> ; ) <term> 
剩余输入串:) ; # 
推导所用产生式:<term> -> $

第69步
当前分析栈:# <block> ; ) 
剩余输入串:) ; # 
匹配 :)

第70步
当前分析栈:# <block> ; 
剩余输入串:; # 
匹配 :;

第71步
当前分析栈:# <block> 
剩余输入串:# 
推导所用产生式:<block> -> <declare_closure> <block_closure>

第72步
当前分析栈:# <block_closure> <declare_closure> 
剩余输入串:# 
推导所用产生式:<declare_closure> -> $

第73步
当前分析栈:# <block_closure> 
剩余输入串:# 
推导所用产生式:<block_closure> -> $

第74步
当前分析栈:# 
剩余输入串:# 
当前程序语法分析成功！

第1步
当前分析栈:# <program> 
剩余输入串:int ID [ INT_VALUE ] , ID , ID , ID [ INT_VALUE ] ; # 
推导所用产生式:<program> -> <block>

第2步
当前分析栈:# <block> 
剩余输入串:int ID [ INT_VALUE ] , ID , ID , ID [ INT_VALUE ] ; # 
推导所用产生式:<block> -> <declare_closure> <block_closure>

第3步
当前分析栈:# <block_closure> <declare_closure> 
剩余输入串:int ID [ INT_VALUE ] , ID , ID , ID [ INT_VALUE ] ; # 
推导所用产生式:<declare_closure> -> <per_declaration> <declare_closure>

第4步
当前分析栈:# <block_closure> <declare_closure> <per_declaration> 
剩余输入串:int ID [ INT_VALUE ] , ID , ID , ID [ INT_VALUE ] ; # 
推导所用产生式:<per_declaration> -> <declare> <per_declare_closure> ;

第5步
当前分析栈:# <block_closure> <declare_closure> ; <per_declare_closure> <declare> 
剩余输入串:int ID [ INT_VALUE ] , ID , ID , ID [ INT_VALUE ] ; # 
推导所用产生式:<declare> -> <type> <variable> <initialization>

第6步
当前分析栈:# <block_closure> <declare_closure> ; <per_declare_closure> <initialization> <variable> <type> 
剩余输入串:int ID [ INT_VALUE ] , ID , ID , ID [ INT_VALUE ] ; # 
推导所用产生式:<type> -> int

第7步
当前分析栈:# <block_closure> <declare_closure> ; <per_declare_closure> <initialization> <variable> int 
剩余输入串:int ID [ INT_VALUE ] , ID , ID , ID [ INT_VALUE ] ; # 
Match :int

第8步
当前分析栈:# <block_closure> <declare_closure> ; <per_declare_closure> <initialization> <variable> 
剩余输入串:ID [ INT_VALUE ] , ID , ID , ID [ INT_VALUE ] ; # 
推导所用产生式:<variable> -> <identifier> <index>

第9步
当前分析栈:# <block_closure> <declare_closure> ; <per_declare_closure> <initialization> <index> <identifier> 
剩余输入串:ID [ INT_VALUE ] , ID , ID , ID [ INT_VALUE ] ; # 
推导所用产生式:<identifier> -> ID

第10步
当前分析栈:# <block_closure> <declare_closure> ; <per_declare_closure> <initialization> <index> ID 
剩余输入串:ID [ INT_VALUE ] , ID , ID , ID [ INT_VALUE ] ; # 
Match :ID

第11步
当前分析栈:# <block_closure> <declare_closure> ; <per_declare_closure> <initialization> <index> 
剩余输入串:[ INT_VALUE ] , ID , ID , ID [ INT_VALUE ] ; # 
推导所用产生式:<index> -> [ <factor_type> ]

第12步
当前分析栈:# <block_closure> <declare_closure> ; <per_declare_closure> <initialization> ] <factor_type> [ 
剩余输入串:[ INT_VALUE ] , ID , ID , ID [ INT_VALUE ] ; # 
Match :[

第13步
当前分析栈:# <block_closure> <declare_closure> ; <per_declare_closure> <initialization> ] <factor_type> 
剩余输入串:INT_VALUE ] , ID , ID , ID [ INT_VALUE ] ; # 
推导所用产生式:<factor_type> -> <number>

第14步
当前分析栈:# <block_closure> <declare_closure> ; <per_declare_closure> <initialization> ] <number> 
剩余输入串:INT_VALUE ] , ID , ID , ID [ INT_VALUE ] ; # 
推导所用产生式:<number> -> INT_VALUE

第15步
当前分析栈:# <block_closure> <declare_closure> ; <per_declare_closure> <initialization> ] INT_VALUE 
剩余输入串:INT_VALUE ] , ID , ID , ID [ INT_VALUE ] ; # 
Match :INT_VALUE

第16步
当前分析栈:# <block_closure> <declare_closure> ; <per_declare_closure> <initialization> ] 
剩余输入串:] , ID , ID , ID [ INT_VALUE ] ; # 
Match :]

第17步
当前分析栈:# <block_closure> <declare_closure> ; <per_declare_closure> <initialization> 
剩余输入串:, ID , ID , ID [ INT_VALUE ] ; # 
推导所用产生式:<initialization> -> $

第18步
当前分析栈:# <block_closure> <declare_closure> ; <per_declare_closure> 
剩余输入串:, ID , ID , ID [ INT_VALUE ] ; # 
推导所用产生式:<per_declare_closure> -> , <variable> <initialization> <per_declare_closure>

第19步
当前分析栈:# <block_closure> <declare_closure> ; <per_declare_closure> <initialization> <variable> , 
剩余输入串:, ID , ID , ID [ INT_VALUE ] ; # 
Match :,

第20步
当前分析栈:# <block_closure> <declare_closure> ; <per_declare_closure> <initialization> <variable> 
剩余输入串:ID , ID , ID [ INT_VALUE ] ; # 
推导所用产生式:<variable> -> <identifier> <index>

第21步
当前分析栈:# <block_closure> <declare_closure> ; <per_declare_closure> <initialization> <index> <identifier> 
剩余输入串:ID , ID , ID [ INT_VALUE ] ; # 
推导所用产生式:<identifier> -> ID

第22步
当前分析栈:# <block_closure> <declare_closure> ; <per_declare_closure> <initialization> <index> ID 
剩余输入串:ID , ID , ID [ INT_VALUE ] ; # 
Match :ID

第23步
当前分析栈:# <block_closure> <declare_closure> ; <per_declare_closure> <initialization> <index> 
剩余输入串:, ID , ID [ INT_VALUE ] ; # 
推导所用产生式:<index> -> $

第24步
当前分析栈:# <block_closure> <declare_closure> ; <per_declare_closure> <initialization> 
剩余输入串:, ID , ID [ INT_VALUE ] ; # 
推导所用产生式:<initialization> -> $

第25步
当前分析栈:# <block_closure> <declare_closure> ; <per_declare_closure> 
剩余输入串:, ID , ID [ INT_VALUE ] ; # 
推导所用产生式:<per_declare_closure> -> , <variable> <initialization> <per_declare_closure>

第26步
当前分析栈:# <block_closure> <declare_closure> ; <per_declare_closure> <initialization> <variable> , 
剩余输入串:, ID , ID [ INT_VALUE ] ; # 
Match :,

第27步
当前分析栈:# <block_closure> <declare_closure> ; <per_declare_closure> <initialization> <variable> 
剩余输入串:ID , ID [ INT_VALUE ] ; # 
推导所用产生式:<variable> -> <identifier> <index>

第28步
当前分析栈:# <block_closure> <declare_closure> ; <per_declare_closure> <initialization> <index> <identifier> 
剩余输入串:ID , ID [ INT_VALUE ] ; # 
推导所用产生式:<identifier> -> ID

第29步
当前分析栈:# <block_closure> <declare_closure> ; <per_declare_closure> <initialization> <index> ID 
剩余输入串:ID , ID [ INT_VALUE ] ; # 
Match :ID

第30步
当前分析栈:# <block_closure> <declare_closure> ; <per_declare_closure> <initialization> <index> 
剩余输入串:, ID [ INT_VALUE ] ; # 
推导所用产生式:<index> -> $

第31步
当前分析栈:# <block_closure> <declare_closure> ; <per_declare_closure> <initialization> 
剩余输入串:, ID [ INT_VALUE ] ; # 
推导所用产生式:<initialization> -> $

第32步
当前分析栈:# <block_closure> <declare_closure> ; <per_declare_closure> 
剩余输入串:, ID [ INT_VALUE ] ; # 
推导所用产生式:<per_declare_closure> -> , <variable> <initialization> <per_declare_closure>

第33步
当前分析栈:# <block_closure> <declare_closure> ; <per_declare_closure> <initialization> <variable> , 
剩余输入串:, ID [ INT_VALUE ] ; # 
Match :,

第34步
当前分析栈:# <block_closure> <declare_closure> ; <per_declare_closure> <initialization> <variable> 
剩余输入串:ID [ INT_VALUE ] ; # 
推导所用产生式:<variable> -> <identifier> <index>

第35步
当前分析栈:# <block_closure> <declare_closure> ; <per_declare_closure> <initialization> <index> <identifier> 
剩余输入串:ID [ INT_VALUE ] ; # 
推导所用产生式:<identifier> -> ID

第36步
当前分析栈:# <block_closure> <declare_closure> ; <per_declare_closure> <initialization> <index> ID 
剩余输入串:ID [ INT_VALUE ] ; # 
Match :ID

第37步
当前分析栈:# <block_closure> <declare_closure> ; <per_declare_closure> <initialization> <index> 
剩余输入串:[ INT_VALUE ] ; # 
推导所用产生式:<index> -> [ <factor_type> ]

第38步
当前分析栈:# <block_closure> <declare_closure> ; <per_declare_closure> <initialization> ] <factor_type> [ 
剩余输入串:[ INT_VALUE ] ; # 
Match :[

第39步
当前分析栈:# <block_closure> <declare_closure> ; <per_declare_closure> <initialization> ] <factor_type> 
剩余输入串:INT_VALUE ] ; # 
推导所用产生式:<factor_type> -> <number>

第40步
当前分析栈:# <block_closure> <declare_closure> ; <per_declare_closure> <initialization> ] <number> 
剩余输入串:INT_VALUE ] ; # 
推导所用产生式:<number> -> INT_VALUE

第41步
当前分析栈:# <block_closure> <declare_closure> ; <per_declare_closure> <initialization> ] INT_VALUE 
剩余输入串:INT_VALUE ] ; # 
Match :INT_VALUE

第42步
当前分析栈:# <block_closure> <declare_closure> ; <per_declare_closure> <initialization> ] 
剩余输入串:] ; # 
Match :]

第43步
当前分析栈:# <block_closure> <declare_closure> ; <per_declare_closure> <initialization> 
剩余输入串:; # 
推导所用产生式:<initialization> -> $

第44步
当前分析栈:# <block_closure> <declare_closure> ; <per_declare_closure> 
剩余输入串:; # 
推导所用产生式:<per_declare_closure> -> $

第45步
当前分析栈:# <block_closure> <declare_closure> ; 
剩余输入串:; # 
Match :;

第46步
当前分析栈:# <block_closure> <declare_closure> 
剩余输入串:# 
推导所用产生式:<declare_closure> -> $

第47步
当前分析栈:# <block_closure> 
剩余输入串:# 
推导所用产生式:<block_closure> -> $

第48步
当前分析栈:# 
剩余输入串:# 
当前程序语法分析成功！
